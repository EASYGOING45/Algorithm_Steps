# 376-摆动序列

## 题述

![image-20220206094455596](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220206094455596.png)

## 思路

### 贪心

​	本题要求通过从原始序列中删除或者不删除一些元素来获得子序列，剩下的保持原序。

​	摆动序列就是差值正负交替出现的序列

​	这道题可以使用贪心思想来解决。

​	![image-20220206094642741](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220206094642741.png)

​	局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。

​	整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。

​	局部最优=》全局最优！

​	代码角度：

​	不需要执行删除操作，题目只要求返回最长摆动子序列的长度，那么我们只需要统计数组的峰值数量就可以了。

​	本题代码实现中，还有一些技巧，例如统计峰值的时候，数组最左面和最右面是最不好统计的。

​	例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。

​	所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0

## 题解

### 贪心

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) 
    {
        //贪心  局部峰值个数
        if(nums.size()<=1)
        {
            return nums.size();
        }

        int curDiff=0;  //当前的两数之差
        int preDiff=0;  //上一个两数之差
        int result=1;   //峰值个数 默认最右边有一个峰值
        for(int i=0;i < nums.size()-1;i++)
        {
            //因为默认最右边有一个峰值 所以是 i < nums.size()-1
            curDiff=nums[i+1]-nums[i];  //计算新差值
            if((curDiff > 0 && preDiff <= 0)||(preDiff >= 0&& curDiff < 0))
            {
                //之所以要加上=0的情况是为了考虑一开始的情况
                result++;
                preDiff=curDiff;
            }
        }
        return result;
    }
};
```

![image-20220206094505114](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220206094505114.png)

### Python

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        preDiff,curDiff,result= 0,0,1
        for i in range(len(nums) - 1):
            curDiff = nums[i+1] - nums[i]
            if curDiff * preDiff <= 0 and curDiff != 0:
                #差值为0时不算摆动
                result += 1
                preDiff =curDiff
                #只有当前差值和上一差值一正一负时，才需要使用当前差值替代上一个差值
        return result
```

![image-20220206095500964](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220206095500964.png)

## 思考

​	局部最优=》全局最优