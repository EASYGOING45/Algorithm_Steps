# 435-无重叠区间

## 题述

![image-20220309105954291](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220309105954291.png)

## 思路

​	**冥冥之中感觉要排序，但是究竟是按照右边界排序，还是按照左边界排？**

​	按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的。

​	按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历。

​	题目只是要求移除区间的个数，没有必要去真实的模拟删除区间

​	**按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了**。

​	此时问题就是要求非交叉区间的最大个数。

​	右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。

​	局部最优推出全局最优

## 题解

### C++

```C++
class Solution {
public:
    //排序规则：按照区间右边界进行排序
    static bool cmp(const vector<int>& a,const vector<int>& b)
    {
        return a[1]<b[1];
    }

    int eraseOverlapIntervals(vector<vector<int>>& intervals) 
    {
        if(intervals.size()==0)
        {
            return 0;
        }

        sort(intervals.begin(),intervals.end(),cmp);
        int count =1;   //非交叉区间个数
        int end = intervals[0][1];  //记录区间的分隔点
        for(int i =1;i<intervals.size();i++)
        {
            if(end <= intervals[i][0])
            {
                end=intervals[i][1];
                count++;
            }
        }
        return intervals.size() - count;
    }
};
```

### Python

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0:
            return 0
        intervals.sort(key = lambda x:x[1])
        count = 1   #非交叉区间个数
        end = intervals[0][1]   #区间分割点
        for i in range(1,len(intervals)):
            if end <= intervals[i][0]:
                count += 1
                end = intervals[i][1]
        return len(intervals) - count
```

![image-20220309110324173](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220309110324173.png)

## 思考

总结如下难点：

- 难点一：一看题就有感觉需要排序，但究竟怎么排序，按左边界排还是右边界排。
- 难点二：排完序之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了。
- 难点三：直接求重复的区间是复杂的，转而求最大非重复区间个数。
- 难点四：求最大非重复区间个数时，需要一个分割点来做标记。

