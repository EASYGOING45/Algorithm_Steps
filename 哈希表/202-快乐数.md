# 202-快乐数

## 题述

![image-20220127112501897](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220127112501897.png)

## 思路

​	这道题目看上去貌似一道数学问题，其实并不是！

​	题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要！**

​	**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。**

​	所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。

​	判断sum是否重复出现就可以使用unordered_set。

​	**还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。**

## 题解

```C++
class Solution {
public:
    //取各个位置上的数字之和
    int getSum(int n)
    {
        int sum=0;
        while(n)
        {
            //依次取各个位置上的数字平方和
            sum+=(n%10)*(n%10);
            n/=10;
        }
        return sum;
    }

    bool isHappy(int n) 
    {
        //快乐数  重复置为每个位置上的数字的平方和，无限循环该过程，直至变为1
        //例子：19就是一个快乐数

        //这道题的求和过程中，sum会重复出现，这是破题依据！
        //前面说过，当我们遇到了要快速判断一个元素是否出现在集合里面的时候，我们需要考虑哈希算法
        //判断sum是否重复出现时，我们可以使用unordered_set

        unordered_set<int> set;
        while(1)
        {
            int sum=getSum(n);
            if(sum==1)
            {
                return true;
            }

            //如果这个sum曾经出现过，说明已经陷入了无限循环了，这时我们就可以return false
            if(set.find(sum)!=set.end())
            {
                return false;
            }
            else
            {
                set.insert(sum);
            }
            n=sum;
        }

    }
};
```

![image-20220127112555684](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220127112555684.png)

## 思考

unordered_set的知识我们前面提到过

find如果找不到的话会返回end地址