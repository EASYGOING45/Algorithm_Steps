# 算法-动态规划

## 动态规划方法概述

<font color=cyan size=6>动态规划中每一个状态一定是由上一个状态推导出来的（想一下上课时老师所举的路径由后往前推得的例子），这是它区别于贪心算法的关键点。</font>

> *动态规划是由前一个状态依次推导而得*

### 动态规划一般解题步骤

​	做DP的题目时，时常会陷入一个误区：那就是将状态转移公式（递推公式)死运用，而没有进行实际模拟。

​	状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

​	动态规划问题可以拆解为以下五个步骤，咱们在实际题目中逐渐融会贯通：

- 确定dp数组（dp table 也就是上课时说的辅助备忘录)以及其下标的含义
- 确定状态转移方程（递推公式）
- dp数组应该如何初始化？
- 确定遍历顺序
- 举例模拟推导dp数组

## 典例1-斐波那契数列

![image-20220525094622116](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220525094622116.png)

```python
class Solution:
    def fib(self, n: int) -> int:
        # 动态规划
        if n<= 1:
            return n
        dp=[0] * (n+1) #定义dp数组 长度为n+1 全部初始化为0  
        dp[0] = 0
        dp[1] = 1
        for i in range(2,n+1):
            dp[i] = dp[i-1] + dp[i-2]	#递推公式	
        return dp[n]
```

## 实验2-最大和连续子数组

![image-20220525095836409](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220525095836409.png)

### 动态规划

#### 1、确定dp数组（dp table）以及下标的含义

​	**dp[i]：包括下标i之前的最大连续子序列和为dp[i]**。

#### 2、确定递推公式

​	dp[i]只有两个方向可以推出来：

- dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
- nums[i]，即：从头开始计算当前连续子序列和

#### 3、dp数组如何初始化

​	从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。

​	根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。

#### 4、确定遍历顺序

​	递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。

#### 5、举例推导dp数组

​	以示例一为例，输入：nums = [-2,1,-3,4,-1,2,1,-5,4]，对应的dp状态如下：

![image-20220408092135651](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220408092135651.png)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 动态规划
        if len(nums) == 0:
            return 0
        
        #初始化dp数组
        dp = [0] * len(nums)
        dp[0] = nums[0]
        result = dp[0]
        for i in range(1,len(nums)):
            dp [i] = max(dp[i-1] + nums[i], nums[i])    #递推公式
            result = max(result,dp[i]) #result负责保存dp[i]中的最大值
        return result
```

## 实验2-数组等差子序列

![image-20220525100125655](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220525100125655.png)

​	本题解是基于常规的思考思路，没有任何奇思妙解。
​	首先我们从题目入手，子序列问题一般可以考虑用动态规划来解决，因此我们从这个方面来思考：

​	动态规划的状态设计为
​	

```
dp[i][j]：以nums[i]为结尾的子序列，前一个等差数字是nums[j]。
```

​	动态规划的转移方程设计为
​	

```
dp[i][j] += dp[j][k] + 1，其中nums[k]是在nums[j]之前的等差数字。
```

​	在此过程中，怎么快速找到在nums[j]之前的等差数字nums[k]呢？可以采用哈希表来预存储所有列	表中的数字以及对应的索引！
​	接下来就很简单了，直接看代码好了。

```python
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return 0
        
        #记录数字以及对应的所有索引
        index_dict = collections.defaultdict(list)          
        for i in range(len(nums)):
            index_dict[nums[i]].append(i)
        
        #动态规划方程
        dp = [[0 for _ in range(len(nums))] for _ in range(len(nums))]

        res = 0
        for i in range(len(nums)):
            for j in range(i):
                #寻找nums[k]
                tar = 2 * nums[j] - nums[i]
                #nums[k]必须出现过
                if tar in index_dict:
                    tar_index = index_dict[tar]
                    for k in range(len(tar_index)):
                        #k必须在j之前
                        if tar_index[k] >= j:
                            break
                        dp[i][j] += dp[j][tar_index[k]] + 1
                res += dp[i][j]
        return res
```

