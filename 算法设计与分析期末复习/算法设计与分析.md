# 算法设计与分析

## 基础知识

- 算法：有限条指令的序列
- 算法应具有输入、输出、确定性、有穷性
- 递推方程求解、Hanoi塔问题 书本P12页
- 主定理 书本P19页
- Python中注意for循环后加冒号
- 深复制使用.append[ : ]
- 字符串的join方法：即拼接
- defaultdict 带默认索引值的字典

## 分治策略

- 分治算法通常是递归算法！！！
- 典型：快速排序、二分检索、二路归并排序
- 步骤：划分子问题、求解子问题、子问题综合
- 子问题与原始问题的性质须一样，子问题须可独立求解
- 改进方式：更优划分子问题，通过预处理减小递归计算量
- 芯片测试 书本P28页

### 快速排序

```python
# 快速排序
def swap(array, i, j):
    """交换"""
    temp = array[i]
    array[i] = array[j]
    array[j] = temp
def Partition(array, left, right):
    """实现划分操作"""
    pivot = left  # 基准值
    index = pivot + 1
    i = index
    while i <= right:
        if array[i] < array[pivot]:
            swap(array, i, index)
            index += 1
        i += 1
    swap(array, pivot, index - 1)
    return index - 1
def Quick_Sort(array, left=None, right=None):
    """快速排序算法的最终实现，递归实现"""
    # 初始化left、right isinstance方法主要是针对None情况
    left = 0 if not isinstance(left, int) else left
    right = len(array) - 1 if not isinstance(right, int) else right
    if left < right:
        PartitionIndex = Partition(array, left, right)  # 划分
        Quick_Sort(array, left, PartitionIndex - 1)
        Quick_Sort(array, PartitionIndex + 1, right)
    return array
```

### 二路归并排序

```python
# 归并排序
def merge(left, right):
    """归并操作"""
    result = []
    while left and right:  # 当两个子集都有元素时，比较它们顶部的两个元素
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    while left:
        result.append(left.pop(0))
    while right:
        result.append(right.pop(0))
    return result
def Merge_Sort(array):
    """归并排序"""
    if len(array) < 2:
        return array
    middle = math.floor(len(array) / 2)
    # 分解区间
    leftArray = array[0:middle]
    rightArray = array[middle:]
    return merge(Merge_Sort(leftArray), Merge_Sort(rightArray))  # 递归
```

## 动态规划

- 关键在于递推方程
- 须满足最优子结构性质：一个问题的最优解包含其子问题的最优解
- 路径选择问题：P53页
- 矩阵链相乘问题 P55页
- 投资问题 P60页
- 背包问题 P63页
- 最长公共子序列LCS P65页

### 数组连续子序和

​	![image-20220605201926225](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220605201926225.png)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 动态规划
        if len(nums) == 0:	#边界条件处理
            return 0
        #初始化dp数组
        dp = [0] * len(nums)	
        dp[0] = nums[0]
        result = dp[0]
        for i in range(1,len(nums)):
            dp [i] = max(dp[i-1] + nums[i], nums[i])    #递推公式
            result = max(result,dp[i]) #result负责保存dp[i]中的最大值
        return result	#返回最终结果
```

### 数组等差子序列

<img src="https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220605202028650.png" alt="image-20220605202028650" style="zoom: 80%;" />

```python
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        answer = 0  #答案
        dp = [defaultdict(int) for _ in nums]   #理解为定义一个二维数组 初始化为0
        for i,x in enumerate(nums): #enumarte为一个可迭代对象 i为下标 x为下标对应的数值 这里是以nums[i]为尾项
            for j in range(i):  # 找前面的数对  nums[j],nums[i]  j<i
                d = x - nums[j] #公差
                count = dp[j][d]    #前面统计过的满足条件的个数
                answer += count     #累加
                dp[i][d] += count + 1   #记录新状态
        return answer
```

### 正则匹配

![image-20220605202216867](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220605202216867.png)

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)
        def matches(i: int, j: int) -> bool:	#判断是否匹配
            if i == 0:
                return False
            if p[j - 1] == '.':
                return True
            return s[i - 1] == p[j - 1]
        f = [[False] * (n + 1) for _ in range(m + 1)]
        f[0][0] = True
        for i in range(m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    f[i][j] |= f[i][j - 2]
                    if matches(i, j - 1):
                        f[i][j] |= f[i - 1][j]
                else:
                    if matches(i, j):
                        f[i][j] |= f[i - 1][j - 1]
        return f[m][n]
```

### 接雨水

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 动态规划
        #当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。
        # 使用两个数组来记录左右的最大高度
        # 初始化 dp teble
        leftHeight = [0] * len(height)
        rightHegiht = [0] * len(height)
        leftHeight[0] = height[0]
        for i in range(1,len(height)):	#左侧最高 从左向右遍历
            leftHeight[i] = max(leftHeight[i-1],height[i])
        rightHegiht[-1] = height[-1]
        for i in range(len(height) - 2 , -1, -1):	#右侧最高 从右向左遍历
            rightHegiht[i] = max(rightHegiht[i+1] , height[i])
        result = 0
        for i in range(0,len(height)):
            sumH = min(leftHeight[i],rightHegiht[i]) - height[i]
            result += sumH
        return result
```

## 贪心算法

- 贪心通常依赖于排序！！！ 贪心算法不能解决 0-1背包问题
- 贪心也须满足最优子结构性质
- 核心在于贪心策略的选取 活动选择问题：结束时间早的优先
- 调度问题 P91页 例4.3   最优前缀码（哈夫曼编码）：P98页

### 分发糖果-两次贪心

![image-20220605202655495](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220605202655495.png)

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        #贪心算法 分两个路线进行遍历
        candy = [1] * len(ratings)  #初始化candy数组，每个孩子最少分得一块糖果
        for i in range(1,len(ratings)): #先考虑右孩子比左孩子评分高的情况 从前向后遍历
            if ratings[i] > ratings[i-1]:
                candy[i] = candy[i-1] + 1
        for j in range(len(ratings) - 2,-1,-1): #先考虑左孩子比右孩子评分高的情况 从后向前遍历
            if ratings[j] > ratings[j+1]:
                candy[j] = max(candy[j],candy[j+1] + 1)
        return sum(candy)
```

### 最大数问题

![image-20220605202715415](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220605202715415.png)、

```python
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        # 选择排序法解决
        length = len(nums)  #遍历范围
        nums = list(map(str,nums))  #利用map()函数转为str型
        for i in range(length):
            for j in range(i+1,length):
                if nums[i] + nums[j] < nums[j] + nums[i]:   #交换条件
                    nums[i],nums[j] = nums[j],nums[i]
        return str(int(''.join(nums)))  #.join()转str
```

## 回溯算法

- 回溯常依赖于递归，但也可迭代实现
- 回溯-深度优先
- 分支限界-广度优先
- 回溯法须满足多米诺性质
- 货郎问题 P117页
- 分支限界-最大团问题-P127页

### N皇后

![image-20220605203159965](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220605203159965.png)

```python
class Solution:
    def __init__(self):
        self.result =[]	#初始化数据 注意初始化的位置在__init__方法中
    def isVaild(self,board,row, col):
            #判断同一列是否冲突
            for i in range(len(board)):
                if board[i][col] == 'Q':
                    return False
            # 判断左上角是否冲突
            i = row -1
            j = col -1
            while i>=0 and j>=0:
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j -= 1
            # 判断右上角是否冲突
            i = row - 1
            j = col + 1
            while i>=0 and j < len(board):
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            return True
    def backTracking(self,chessBoard,row,n):
        #如果走到最后一行，就说明已经找到了一个可行解
        if row == n:
            tempResult = []
            for temp in chessBoard:
                tempStr = "".join(temp)
                tempResult.append(tempStr)
            self.result.append(tempResult)
            return
        for col in range(n):
                if self.isVaild(chessBoard, row, col) == False:
                    continue
                chessBoard[row][col] = 'Q'
                self.backTracking(chessBoard, row+1, n)
                chessBoard[row][col] = '.'
    def solveNQueens(self, n: int) -> List[List[str]]:
        self.chessBoard = [['.'] * n for i in range(n)]
        self.backTracking(self.chessBoard,0,n)	#递归起始
        return self.result
```

### 单词拆分

![image-20220605203352658](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220605203352658.png)

```python
class Solution:
    # 带备忘录的记忆化搜索
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        result = []
        memo = [1] * (len(s)+1)
        wordDict = set(wordDict)
        def BackTracking(wordDict,temp,pos):
            num = len(res)                  # 回溯前先记下答案中有多少个元素
            if pos == len(s):
                res.append(" ".join(temp))
                return
            for i in range(pos,len(s)+1):
                if memo[i] and s[pos:i] in wordDict: # 添加备忘录的判断条件
                    temp.append(s[pos:i])
                    dfs(wordDict,temp,i)
                    temp.pop()
            # 答案中的元素没有增加，说明s[pos:]不能分割，修改备忘录        
            memo[pos] = 1 if len(res) > num else 0 
        BackTracking(wordDict,[],0)
        return result
```

