# 509-斐波那契数列

## 题述

![image-20220407123742135](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220407123742135.png)

## 思路

​	斐波那契数列应该很熟悉，大一上学期学C++的时候就接触过，这道题其实非常适合作为动态规划的第一道入门题，或许你不需要多想直接就能够唰唰写出代码，但是做简单题的目的是为了熟悉动态规划的五个步骤，我们把这道题做细。

### 动态规划

#### 1、确定dp数组以及其下标的含义

​	dp[i]的定义为：第i个数的斐波那契数值是dp[i]

#### 2、确定递推公式

​	为什么这是一道非常简单的入门题目呢？

​	**因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

#### 3、dp数组如何初始化

​	**题目中把如何初始化也直接给我们了，如下：**

```
dp[0] = 0;
dp[1] = 1;
```

#### 4、确定遍历顺序

​	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

#### 5、举例模拟推导dp数组

​	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

​	0 1 1 2 3 5 8 13 21 34 55

​	如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

## 题解

### C++

```C++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};

```

### Python3

```python
class Solution:
    def fib(self, n: int) -> int:
        # 动态规划解决斐波那契数列问题
        # fib[0] = 0         fib[1] =1
        if n < 2:
            return n
        a , b = 0 , 1
        for i in range(1,n):
            c = a + b
            a, b = b, c
        return c
```

![image-20220407124635021](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220407124635021.png)

## 思考

​	斐波那契数列这道题目是非常基础的题目，通过它去感受DP的解题过程。

​	简单题是用来掌握方法论的，动规五部曲将在接下来的动态规划讲解中发挥重要作用！

> *2022-4-7-12：47*

