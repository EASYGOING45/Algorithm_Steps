# 140-单词拆分Ⅱ

## 题述

![image-20220526100801964](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220526100801964.png)

## 思路

​	使用回溯法的模板去进行编码

​	看代码去理解

## 题解

### 这个版本会超时

```Python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        result = [] #结果数组
        wordDict = set(wordDict)    #使用set进行去重

        def BackTracking(wordDict,temp,pos):
            #递归函数
            if pos == len(s):   #pos为遍历到的位置 类似于startIndex
                #递归终止条件
                result.append(" ".join(temp))
                return
            for i in range(pos,len(s)+1):   #横向遍历
                if s[pos:i] in wordDict:
                    #判断是不是在单词字典中 使用in
                    temp.append(s[pos:i])
                    BackTracking(wordDict,temp,i)
                    temp.pop()
        BackTracking(wordDict,[],0)
        return result
```

### 剪枝优化

```Python
class Solution:
    # 带备忘录的记忆化搜索
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        result = []
        memo = [1] * (len(s)+1)
        wordDict = set(wordDict)

        def BackTracking(wordDict,temp,pos):
            num = len(res)                  # 回溯前先记下答案中有多少个元素
            if pos == len(s):
                res.append(" ".join(temp))
                return
            for i in range(pos,len(s)+1):
                if memo[i] and s[pos:i] in wordDict: # 添加备忘录的判断条件
                    temp.append(s[pos:i])
                    dfs(wordDict,temp,i)
                    temp.pop()
            # 答案中的元素没有增加，说明s[pos:]不能分割，修改备忘录        
            memo[pos] = 1 if len(res) > num else 0 
            
        BackTracking(wordDict,[],0)
        return result
```

![image-20220526103122470](https://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20220526103122470.png)

## 思考