# 121-买卖股票的最佳时机

## 题述

![image-20210829144041682](http://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20210829144041682.png)

## 浅析

这道题  第一想法是对vector进行排序，然后直接将最大值-最小值，可是想了想，最高点出现的日期不一定在最低点出现日期前，所以行不通。

那么，是不是也可以直接进行暴力双循环呢？  可以，但是会超时。

一次遍历法也可行，效率也更高。

我们用一个变量记录一个历史最低价格，假设在那天购入，那么我们在第i天的利润就是prices[i]-minprice.

我们只需要遍历价格数组一遍，记录历史最低点，然后再每一天考虑以下问题：

如果我们再历史最低点买进的这支股票，我今天卖出能赚多少钱？

## 代码

### 暴力双循环

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        int n = prices.size(), profit = 0;
        for (int i = 0; i < n; ++i){
            for (int j = i + 1; j < n; ++j) {
                profit = max(profit, prices[j] - prices[i]);
            }
        }
        return profit;
    }
};
```

### 一次遍历

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        int inf = 1e9;    //定义一个最小值
        int minprice = inf, maxprofit = 0;
        // for (int price: prices)     //C++新特性写法  看看应该能看到
        // {
        //     maxprofit = max(maxprofit, price - minprice);
        //     minprice = min(price, minprice);
        // }


        int n=prices.size();
        for(int i=0;i<n;i++)
        {
            maxprofit=max(maxprofit,prices[i]-minprice);
            minprice=min(prices[i],minprice);
        }
        return maxprofit;
    }
};

```



## AC

![image-20210829144636200](http://happygoing.oss-cn-beijing.aliyuncs.com/img/image-20210829144636200.png)